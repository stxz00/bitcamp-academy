package com.bit.day20;
//멀티작업
// 원칙적으로는 말이 안됨. 완벽한 멀티는 없음.
// 시그날 : 컴퓨터적 시간을 잘게 쪼개서 일을 잠깐씩 쓰는 것
// 시간을 쓰는 기준 : 프로세스 단위로 일을 잠깐씩 함.
// 단일스레드 단일프로세스(명령 프롬프트,dos)
// 하드웨어의 발달은 보통 소프트웨어의 발달로 이룸
// IBM에서 차세대 운영체제 8비트체계 OS2를 개발(오퍼레이팅 시스템2) MS사가 인수함. 그러다 16비트로 체계 등으로 발전
// 이후 MS사가 window1.0 만듬 -> 망함
// window3.1 때부터 돋보임. 이때까지도 dos에 그래픽을 입힌 상태
// window xp 이전에 문제는 블루스크린이 자주 떴음. dos기반의 한계. -> 멀티작업에 특화되지 않았기 때문
// 블루스크린 : 프로세스가 올리고 내리는 일을 하다 변모함. 고장나니 내려놓을 수 없는 상황.(데드락)
// 그러므로 단일 프로세스의 경우 매우 치명적임. 
// 극복을 위해선 다중 프로세스, 과거엔 프로세스에 프로그램, 현재는 하나의 프로그램이 돌아가고 있지만 다중 스레드가 돌아가고 있는 것
// 그 이후부터 멀티작업이 되게 함.

// 데드락 시 프로세스가 아닌 스레드가 문제 생긴것이므로 프로세스는 사실상 문제가 없음.(명령만 시킬뿐)
// 스레드가 무한루프 (응답없음 : 데드락) 걸리면 
// 그 스레드를 별도로 관리하고 다른 스레드들은 일하는 것(나중에 응답이 아예 없으면 프로세스를 죽일지 물어보는 것.) 
// 예전엔 그것이 블루스크린이었고 하나의 프로세스였으니 운영체제,시스템 등 데드락 때문에 문제생기니 재부팅밖에 답이 없었음.
// 프로세스를 나누는 것은 창 2개 키는 그런거고 우리가 하나의 프로세스 안에서 나눠지는 스레드를 제어
// 우리는 그동안 main이라는 하나의 스레드를 써왔던 것
// UI할 때 다중 창 사용함. main이 생성자 생성하고 리턴 했는데도 UI창이 떠있음 즉, 2개의 멀티 스레드를 한 것.



// 스레드 상속이 가장 쉬움 방법
public class Ex10 extends Thread{
	
	public static void main(String[] args) {
		System.out.println("메인스레드 시작");
		
		Ex10 me = new Ex10();
//		me.run(); // 이렇게만 했을때는 다른 것 없음
		me.start(); // 메인 스레드가 끝났음에도 일을 하고 있음 -> 독립적으로 실행함
		
		Ex10 me2 = new Ex10();

		me2.start(); // 코어에게 실행하라고 떤짐. main부터 다 끝낼때까지 실행대기
		
		//누가 먼저실행될지는 모름
		
		System.out.println("메인스레드 종료"); //다중 스레드
	}
	
	@Override
	public void run() {
		System.out.println("새로운 스레드시작");
		System.out.println("새로운 스레드종료");
	}
	
	
}
	